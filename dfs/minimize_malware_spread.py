# Approach 1: DFS
class Solution:
    def minMalwareSpread(self, graph, initial):
        n = len(graph)
        initial = set(initial)
        g_vis = set()

        node_to_del, comp_size = min(initial), 0
        for node in range(n):
            if node in g_vis: continue
            vis = set([node])
            self.dfs(graph, node, vis)
            g_vis |= vis
            infectors = vis & initial

            if len(infectors) == 1:
                first = infectors.pop()
                if len(vis) > comp_size or (len(vis) == comp_size and first < node_to_del):
                    node_to_del, comp_size = first, len(vis)

        return node_to_del

    def dfs(self, graph, node, visited):
        for v in range(len(graph[node])):
            if graph[node][v] != 1 or v in visited: continue
            visited.add(v)
            self.dfs(graph, v, visited)


# Approach 2: UF
class DS:
    def __init__(self):
        self.parent = {}
        self.rank = {}
        self.size = {}

    def find(self, x):
        if x != self.parent[x]: self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def has_parent(self, x):
        return x in self.parent

    def set_parent(self, x):
        self.parent[x] = x
        self.rank[x] = 0
        self.size[x] = 1

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py: return

        if self.rank[px] > self.rank[py]:
            self.parent[py] = px
            self.size[x] += 1
        elif self.rank[py] > self.rank[px]:
            self.parent[px] = py
            self.size[y] += 1
        else:
            self.parent[py] = px
            self.rank[px] += 1
            self.size[x] += 1

import collections
class SolutionDS:
    def minMalwareSpread(self, graph, initial):
        ds = DS()
        for j, row in enumerate(graph):
            if not ds.has_parent(j): ds.set_parent(j)
            for i, val in enumerate(row):
                if not ds.has_parent(i): ds.set_parent(i)
                if val == 1: ds.union(i, j)

        counts = collections.Counter(ds.find(u) for u in initial)
        ans = (-1, min(initial))
        for node in initial:
            root = ds.find(node)
            if counts[root] != 1: continue

            score = ds.size[root]
            if score > ans[0] or score == ans[0] and node < ans[1]:
                ans = (score, node)

        return ans[1]


# 924. Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/


# Approach 1:
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

# Approach 2:
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N). 


sol = SolutionDS()
assert sol.minMalwareSpread(
    [[1, 0, 0, 0],
     [0, 1, 0, 0],
     [0, 0, 1, 1],
     [0, 0, 1, 1]],
    [3, 1]
) == 3
assert sol.minMalwareSpread(
    [[1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
     [0, 1, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
     [1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
     [0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0, 1],
     [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
     [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
     [0, 0, 0, 0, 0, 0, 1, 0, 0, 1]],
    [1, 3, 0]
) == 1
