# Approach 1: DFS
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.items():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.items():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]


class Solution:
    def minMalwareSpread(self, graph, initial):
        def dfs(i):
            seen.add(i)
            return not any(graph[i][j] and j not in seen and (j in initials or not dfs(j)) for j in range(len(graph[i])))

        res, mx, initials = min(initial), 1, set(initial)
        for node in sorted(initial):
            impact = set()

            for j in range(len(graph[node])):
                seen = {node}
                if graph[node][j] and j not in initials and dfs(j): impact |= seen

            if len(impact) > mx: res, mx = node, len(impact)

        return res

# Approach 2: Union-Find
class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]


class Solution(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter()
        node_to_compo = {}
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.iteritems():
            score = 0
            for c in components:
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)

        return best[1]

# 928. Minimize Malware Spread II
# https://leetcode.com/problems/minimize-malware-spread-ii/

# Approach 1: DFS
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

# Approach 2: Union-Find
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).