require 'set'

# Approach 1: DFS
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    # Rank stores components sizes as keys and
    # list of corresponding infected nodes, that can disinfect a component
    rank = Hash.new { |h, k| h[k] = [] }
    initial = Set.new(initial.sort!())

    # For each node do a DFS, with a fresh visited set
    initial.each do |node|
        @visited = Set.new()
        dfs(node, graph, @visited)
        # caculate the number of infecting nodes in the connected component
        component_infectors = @visited & initial
        rank[@visited.size()].push(node) if component_infectors.size == 1
    end

    !rank.empty? ? rank[rank.keys.max][0] : initial.first
end

def dfs(i, graph, visited)
    visited.add(i)
    0.upto(graph[i].size() - 1) do |j|
        next if graph[i][j] != 1 || visited.include?(j)
        dfs(j, graph, visited)
    end
end


# Approach 2: Union-Find
class DisjoinSet
    attr_accessor :p, :sz
    def initialize(n)
        @p = (0...n).to_a       # Parents array of size n
        @sz = Array.new(n, 1)   # We need sizes for max impact disinfecting
    end

    def find(x)
        @p[x] != x ? @p[x] = find(@p[x]) : @p[x]
    end

    def union(x, y)
        x_set, y_set = find(x), find(y)
        @p[x_set] = y_set
        @sz[y_set] += @sz[x_set]
    end

    def size(x)
        @sz[find(x)]
    end
end

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread2(graph, initial)
    ds = DisjoinSet.new(graph.size())

    # Construct disjoint sets
    graph.each_with_index do |row, j|
        0.upto(j - 1) do |i|
            ds.union(i, j) if row[i] == 1 # join the sets, as there is an edge
        end
    end

    counts = Hash.new { |h, k| h[k] = 0 }
    infected_sets = initial.map do |node|
        ds.find(node)
    end

    # Count sizes of each connected component
    infected_sets.each { |n| counts[n] += 1 }

    # Find the component of max size that has only 1 infecting node
    ans = [-1, initial.min]
    initial.each do |node|
        root = ds.find(node)
        next if counts[root] != 1                       # Skip if not only 1 infecting node, only then we have successful disinfection
        score = ds.size(root)
        # max set or same as max set and smaller node index
        ans = [score, node] if score > ans[0] || score == ans[0] && node < ans[1]
    end

    ans[1]
end

# 924. Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/

# KEY INSIGHT
# If number of infecting nodes in a connected component is 1,
# only then we can disinfect that component by removing that one node
# Anything else (< 1 or > 1) would mean we can't disinfect that node by removing that node
# either because there is no infecting node
# or because even if we remove 1 infecting node, the component is still infected
# Good explanation here:
# https://leetcode.com/problems/minimize-malware-spread/discuss/181186/python-dfs-solution-with-picture-to-explain-my-thought(with-extra-Chinese-explanation)

# Approach 1: DFS
# 1. For each node in initial do a dfs to get the component set
# 2. Intersection of the components with the initial will
#    give us the infectors for that component
# 3. If number of component infectors is 1,
#    only then removal of that infector will cause
#    that component to be disinfected
# 4. Keep a hash (rank) of every component size and
#    infected nodes that can cause a successful disinfection
# 5. If the rank hash is empty then return the minimum node from initial
# 6. else, return the minimum element of the maximum component size

# Time: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space: O(N)

# Approach 2: Union-Find Algorithm
# 1. Process the graph and construct the disjoin sets
# 2. Keep a counts hash to track sizes of each set or connected component
# 3. For each initial node check if the corresponding has only 1 infecting node
# 4. Also find the max such component and return min node for max size component

# Time: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space: O(N). 

require 'set'
require 'test/unit'
extend Test::Unit::Assertions

graph = [[1,0,0,0],
         [0,1,0,0],
         [0,0,1,1],
         [0,0,1,1]]
initial = [3,1]
assert_equal(min_malware_spread(graph, initial), 3)
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0, 1]
assert_equal(min_malware_spread(graph, initial), 0)
graph = [[1,0,0],
         [0,1,0],
         [0,0,1]]
initial = [0, 2]
assert_equal(min_malware_spread(graph, initial), 0)
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1,2]
assert_equal(min_malware_spread(graph, initial), 2)


# Tests for union-find
graph = [[1,0,0,0],
         [0,1,0,0],
         [0,0,1,1],
         [0,0,1,1]]
initial = [3,1]
assert_equal(min_malware_spread2(graph, initial), 3)
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0, 1]
assert_equal(min_malware_spread2(graph, initial), 0)
graph = [[1,0,0],
         [0,1,0],
         [0,0,1]]
initial = [0, 2]
assert_equal(min_malware_spread2(graph, initial), 0)
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1,2]
assert_equal(min_malware_spread2(graph, initial), 2)
