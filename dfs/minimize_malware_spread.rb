require 'set'

# Approach 1: DFS
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    n = graph.size
    initial = Set.new(initial)          # Make initial a set
    g_vis = Set.new()                   # Represents graph level visited set

    node_to_del, comp_size = initial.min, 0

    0.upto(n - 1) do |node|
        next if g_vis.include?(node)    # Skip if visited

        vis = Set.new([node])           # Start a new component, because an unvisited node means a new component
        dfs(graph, node, vis)           # After dfs vis should contain the entire component
        g_vis |= vis                    # Set Union to make all the component level visited nodes to graph level visited nodes
        infectors = vis & initial     # Set Intersection to get the nodes of this component that are infecting the rest

        if infectors.size == 1        # We only select components that have only 1 infecting node > 1 will have no use of deleting 1 node
            if vis.size > comp_size || (vis.size == comp_size && infectors.first < node_to_del)
                node_to_del, comp_size = infectors.first, vis.size
            end
        end

    end

    node_to_del
end

def dfs(graph, node, visited)
    0.upto(graph[node].size - 1) do |v|
        next if graph[node][v] != 1 || visited.include?(v)
        visited.add(v)
        dfs(graph, v, visited)
    end
end


# Approach 2: Union-Find
class DisjoinSet
    attr_accessor :p, :sz
    def initialize(n)
        @p = (0...n).to_a       # Parents array of size n
        @sz = Array.new(n, 1)   # We need sizes for max impact disinfecting
    end

    def find(x)
        @p[x] != x ? @p[x] = find(@p[x]) : @p[x]
    end

    def union(x, y)
        x_set, y_set = find(x), find(y)
        @p[x_set] = y_set
        @sz[y_set] += @sz[x_set]
    end

    def size(x)
        @sz[find(x)]
    end
end

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread2(graph, initial)
    ds = DisjoinSet.new(graph.size())

    # Construct disjoint sets
    graph.each_with_index do |row, j|
        0.upto(j - 1) do |i|
            ds.union(i, j) if row[i] == 1 # join the sets, as there is an edge
        end
    end

    counts = Hash.new { |h, k| h[k] = 0 }
    infected_sets = initial.map do |node|
        ds.find(node)
    end

    # Count sizes of each connected component
    infected_sets.each { |n| counts[n] += 1 }

    # Find the component of max size that has only 1 infecting node
    ans = [-1, initial.min]
    initial.each do |node|
        root = ds.find(node)
        next if counts[root] != 1                       # Skip if not only 1 infecting node, only then we have successful disinfection
        score = ds.size(root)
        # max set or same as max set and smaller node index
        ans = [score, node] if score > ans[0] || score == ans[0] && node < ans[1]
    end

    ans[1]
end

# 924. Minimize Malware Spread
# https://leetcode.com/problems/minimize-malware-spread/

# Key Insight
# For a given graph, we can divide it into several connected components.
# as picture below shows, the yellow node is infected initially. (Refer picture with same name)
# if we don't do anything, the all 8 nodes will be infected in the end.
# how about fix the node 1? it's useless because the node 3 is infected, and all nodes in the component will be infected in the end.
# how about fix the node 3? it's same as fix the node 1
# how about fix the node 5? ok, we can make three nodes(2,5,7) safe.

# So, we find that if a component contains >= 2 infected nodes in it, we cannot change the number of infected node.
# if we want to minimize the number of infected node, we should find the comp which should have excatly one infected node.

# so the process should be 3 steps:
# step 1: For each component
# step 2: caculate the number of infected node in the component,as cnt,if cnt == 1,go to step 3; else go to step 1.
# step 3: compare the number of node in this subgraph, and select the maximum number

# Approach 1: DFS
# 1. For each node in initial do a dfs to get the component set
# 2. Intersection of the components with the initial will
#    give us the infectors for that component
# 3. If number of component infectors is 1,
#    only then removal of that infector will cause
#    that component to be disinfected
# 4. return the minimum node label of the maximum component size

# Time: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space: O(N)

# Approach 2: Union-Find Algorithm
# 1. Process the graph and construct the disjoin sets
# 2. Keep a counts hash to track sizes of each set or connected component
# 3. For each initial node check if the corresponding has only 1 infecting node
# 4. Also find the max such component and return min node for max size component

# Time: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space: O(N).

require 'set'
require 'test/unit'
extend Test::Unit::Assertions

graph = [[1,0,0,0],
         [0,1,0,0],
         [0,0,1,1],
         [0,0,1,1]]
initial = [3,1]
assert_equal(min_malware_spread(graph, initial), 3)
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0, 1]
assert_equal(min_malware_spread(graph, initial), 0)
graph = [[1,0,0],
         [0,1,0],
         [0,0,1]]
initial = [0, 2]
assert_equal(min_malware_spread(graph, initial), 0)
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1,2]
assert_equal(min_malware_spread(graph, initial), 2)


# Tests for union-find
graph = [[1,0,0,0],
         [0,1,0,0],
         [0,0,1,1],
         [0,0,1,1]]
initial = [3,1]
assert_equal(min_malware_spread2(graph, initial), 3)
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0, 1]
assert_equal(min_malware_spread2(graph, initial), 0)
graph = [[1,0,0],
         [0,1,0],
         [0,0,1]]
initial = [0, 2]
assert_equal(min_malware_spread2(graph, initial), 0)
graph = [[1,1,0],[1,1,0],[0,0,1]]
initial = [0,1,2]
assert_equal(min_malware_spread2(graph, initial), 2)
