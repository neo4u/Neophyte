require 'set'

# Approach 1: DFS
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    n = graph.size
    initial = Set.new(initial)
    clean = Set.new((0...n).to_a) - initial # nodes not in initial

    # For each node u in initial, we use dfs to find
    # 'visited': all nodes in clean that it can reach,
    infected_by = Hash.new { |h, k| h[k] = [] }
    initial.each do |u|
        visited = Set.new()
        dfs(u, graph, visited, clean)

        # For each node v that was visited, u infects v
        visited.each { |v| infected_by[v].push(u) }
    end

    # For each node u in initial, for every v not in initial
    # that is uniquely infected by u, add 1 to the contribution for u.
    contribution = Hash.new { |h, k| h[k] = 0 }
    infected_by.each do |v, nbs|
        contribution[nbs[0]] += 1 if nbs.size == 1
    end

    # Take the best answer
    best = [-1, initial.min]
    contribution.each do |u, score|
        best = [score, u] if score > best[0] || score == best[0] && u < best[1]
    end

    best[1]
end

def min_malware_spread(graph, initial)
    n = graph.size
    initial = Set.new(initial)
    clean = Set.new((0...n).to_a) - initial
    
    nodes_to_infectors = Hash.new { |h, k| h[k] = [] }
    initial.each do |node|
        visited = Set.new()
        dfs(graph, node, visited, clean)
        visited.each { |v| nodes_to_infectors[v].push(node) }
    end

    contribution = Hash.new { |h, k| h[k] = 0 }
    infected_by.each do |node, nbs|
        contribution[nbs.first] += 1 if nbs.size == 1
    end
    
    impact, node_to_del = [-1, initial.min]
    contribution.each do |node, node_impact|
        node_to_del, impact = node, node_impact if node_impact > impact || node_impact == impact && node < node_to_del
    end
    
    node_to_del
end

def dfs(graph, u, visited, clean)
    0.upto(graph[u].size - 1) do |v|
        next if visited.include?(v) || !clean.include?(v) || graph[u][v] != 1
        visited.add(v)
        dfs(graph, v, visited, clean)
    end
end

def dfs(u, graph, visited, clean)
    0.upto(graph[u].size - 1) do |v| # element gives us adj and index gives us vertex
        if graph[u][v] == 1 && clean.include?(v) && !visited.include?(v)
            visited.add(v)
            dfs(v, graph, visited, clean)
        end
    end
end

# Approach 2: Union-Find (Seems faster for leetcode inputs)
class DisjoinSet
    attr_accessor :p, :sz
    def initialize(n)
        @p = (0...n).to_a       # Parents array of size n
        @sz = Array.new(n, 1)   # We need sizes for max impact disinfecting
    end

    def find(x)
        @p[x] != x ? @p[x] = find(@p[x]) : @p[x]
    end

    def union(x, y)
        x_set, y_set = find(x), find(y)
        @p[x_set] = y_set
        @sz[y_set] += @sz[x_set]
    end

    def size(x)
        @sz[find(x)]
    end
end

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread2(graph, initial)
    n = graph.size
    initial = Set.new(initial)
    clean = Set.new((0...n).to_a) - initial # nodes not in initial
    ds = DisjoinSet.new(n)

    # clean[u] == 1 if it's a node in the graph not in initial.
    clean.each do |u|
        clean.each do |v|
            ds.union(u, v) if graph[u][v] == 1
        end
    end
    # ds now represents the components of the graph without
    # any nodes from initial. Let's call this graph G.

    # `counts` maps component indexes to the counts of infecting nodes u from
    # initial directly infecting that component
    counts = Hash.new { |h, k| h[k] = 0 }
    
    node_to_compo = {}
    initial.each do |u|
        components = Set.new()
        clean.each { |v| components.add(ds.find(v)) if graph[u][v] == 1 }

        node_to_compo[u] = components
        components.each { |c| counts[c] += 1 }
    end

    # For each node u in initial, nodeToCompo.get(u)
    # now has every component from G that u neighbors.
    best = [-1, nil] # score, node
    node_to_compo.each do |u, components|
        score = 0
        components.each do |c| 
            score += ds.size(c) if counts[c] == 1 # uniquely infected
        end
        best = [score, u] if score > best[0] || score == best[0] && u < best[1]
    end

    return best[1]
end


# 928. Minimize Malware Spread II
# https://leetcode.com/problems/minimize-malware-spread-ii/

# Difference from Minimie malware I is that there we're only removing one node from initially infected nodes.
# Here we're removing node and its edges from the graph (affects the component)

# Intuition
# Let G be the graph with all the nodes in initial removed.
# For each component of G, either it neighbors 0, 1, or >= 2 nodes from initial.
# The result only changes if there is exactly 1 neighbor from initial, so we need a way to count this.


# Approach 1: DFS
# 0. Let graph G of clean nodes (set of nodes - set(initial))
# 1. Construct infected_by hash which maps clean nodes v to a list of nodes u that they're infected by
#    - This is formed by looping through initial
#    - doing a dfs from initial such that we visit only unvisited clean nodes
#    - Thus we arrive at a hash for every v in clean, we get a list of u's in intial that infect v
# 2. Construct contribution hash which maps nodes v that are uniquely infected by u from initial (nbs.size == 1)
#    to their directly infected nodes
#    (path exists from infected node to this node without another infected node in between)
#    - We construct contribution by looping through infected_by
#    - Adding the infecting node u from initial that uniquely infects v from every v
#    - We map that to the count of v's that are uniquely infected by every such u (from initial)
# 3. Take the max contribution node with the least node index
#    - we do this by looping through contribution hash
#    - The keys are u nodes and the values are impact scores for each u
#    - Keep a running maximam of impacts and keep updating score, node
#      only if we find a better score or we find a smaller node label when scores are equal

# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

# Approach 2: Union-Find

# 0. Let graph G of clean nodes (set of nodes - set(initial))
# 1. Form disjoint sets for every pair u, v in clean graph
# 2. for each node in initial construct a node_to_components hash
#    and loop through the affected components and update the components to infecting nodes array
# 3. Now chose the max score and min index node by looping through the node_to_compo hash
# 4. Return such a maximal score node with minimal index

# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

require 'set'
require 'test/unit'
extend Test::Unit::Assertions

# 0, 1 can only spread to each other, thus least index is 0
#     0
#    /
#   /
#  1     2
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 0)

# 1 can spread to 2. 0 can't directly spread to 2
# so removing 1 will cause the most impact, it will cause 0 and 2 to be come diffrent components
#     0
#    /
#   / 
#  1-----2
graph = [[1,1,0],
         [1,1,1],
         [0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 1)

# 1 can spread to 2 and 3, 0 can't directly spread to 2 or 3
# So removing 1 will have most impact
#     0
#    /
#   / 
#  1-----2-----3
graph = [[1,1,0,0],
         [1,1,1,0],
         [0,1,1,1],
         [0,0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 1)

# 2 can spread to 3. 0 and 1 can't directly spread to 2 or 3
# So removing 2 will have most impact
#     0
#    /
#   / 
#  1-----2-----3
graph = [[1,1,0,0],
         [1,1,1,0],
         [0,1,1,1],
         [0,0,1,1]]
initial = [0,1,2]
assert_equal(min_malware_spread(graph, initial), 2)

# Tests for union-find
graph = [[1,1,0],[1,1,1],[0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread2(graph, initial), 1)
graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread2(graph, initial), 1)
graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
initial = [0,1,2]
assert_equal(min_malware_spread2(graph, initial), 2)