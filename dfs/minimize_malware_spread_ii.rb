require 'set'

# Approach 1: DFS
# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread(graph, initial)
    initial = Set.new(initial)
    n = graph.size
    clean = Set.new((0...n).to_a) - initial # nodes not in initial

    # For each node u in initial, we use dfs to find
    # 'visited': all nodes not in initial that it can reach,
    infected_by = Hash.new { |h, k| h[k] = [] }
    initial.each do |u|
        visited = Set.new()
        dfs(u, graph, visited, clean)

        # For each node v that was visited, u infects v
        visited.each { |v| infected_by[v].push(u) } 
    end

    # For each node u in initial, for every v not in initial
    # that is uniquely infected by u, add 1 to the contribution for u.
    contribution = Hash.new { |h, k| h[k] = 0 }
    infected_by.each do |v, nbs|
        contribution[nbs[0]] += 1 if nbs.size == 1
    end

    # Take the best answer
    best = [-1, initial.min]
    contribution.each do |u, score|
        best = [score, u] if score > best[0] || score == best[0] && u < best[1]
    end

    best[1]
end

def dfs(u, graph, visited, clean)

    graph[u].each_with_index do |adj, v|
        if adj == 1 && clean.include?(v) && !visited.include?(v)
            visited.add(v)
            dfs(v, graph, visited, clean)
        end
    end
end

# Approach 2: Union-Find
class DisjoinSet
    attr_accessor :p, :sz
    def initialize(n)
        @p = (0...n).to_a       # Parents array of size n
        @sz = Array.new(n, 1)   # We need sizes for max impact disinfecting
    end

    def find(x)
        @p[x] != x ? @p[x] = find(@p[x]) : @p[x]
    end

    def union(x, y)
        x_set, y_set = find(x), find(y)
        @p[x_set] = y_set
        @sz[y_set] += @sz[x_set]
    end

    def size(x)
        @sz[find(x)]
    end
end

# @param {Integer[][]} graph
# @param {Integer[]} initial
# @return {Integer}
def min_malware_spread2(graph, initial)
    n = graph.size
    initial = Set.new(initial)
    clean = Set.new((0...n).to_a) - initial # nodes not in initial
    ds = DisjoinSet.new(n)

    # clean[u] == 1 if it's a node in the graph not in initial.
    clean.each do |u|
        clean.each do |v|
            ds.union(u, v) if graph[u][v] == 1
        end
    end

    # ds now represents the components of the graph without
    # any nodes from initial.  Let's call this graph G.
    counts = Hash.new { |h, k| h[k] = 0 }
    node_to_compo = {}
    initial.each do |u|
        components = Set.new()
        clean.each do |v|
            components.add(ds.find(v)) if graph[u][v] == 1
        end
        node_to_compo[u] = components

        components.each do |c|
            counts[c] += 1
        end
    end

    # For each node u in initial, nodeToCompo.get(u)
    # now has every component from G that u neighbors.
    best = [-1, nil] # score, node
    node_to_compo.each do |u, components|
        score = 0
        components.each do |c| 
            score += ds.size(c) if counts[c] == 1 # uniquely infected
        end
        best = [score, u] if score > best[0] || score == best[0] && u < best[1]
    end

    return best[1]
end


# 928. Minimize Malware Spread II
# https://leetcode.com/problems/minimize-malware-spread-ii/

# Approach 1: DFS
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

# Approach 2: Union-Find
# Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
# Space Complexity: O(N).

require 'set'
require 'test/unit'
extend Test::Unit::Assertions

# 0, 1 can only spread to each other, thus least index is 0
#     0
#    /
#   /
#  1     2
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 0)

# 1 can spread to 2. 0 can't directly spread to 2
# so removing 1 will cause the most impact
#     0
#    /
#   / 
#  1-----2
graph = [[1,1,0],
         [1,1,1],
         [0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 1)

# 1 can spread to 2 and 3, 0 can't directly spread to 2 or 3
# So removing 1 will have most impact
#     0
#    /
#   / 
#  1-----2-----3
graph = [[1,1,0,0],
         [1,1,1,0],
         [0,1,1,1],
         [0,0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 1)

# 2 can spread to 3. 0 and 1 can't directly spread to 2 or 3
# So removing 2 will have most impact
#     0
#    /
#   / 
#  1-----2-----3
graph = [[1,1,0,0],
         [1,1,1,0],
         [0,1,1,1],
         [0,0,1,1]]
initial = [0,1,2]
assert_equal(min_malware_spread(graph, initial), 2)

# 0, 1 can only spread to each other, thus least index is 0
#     0
#    /
#   /
#  1     2
graph = [[1,1,0],
         [1,1,0],
         [0,0,1]]
initial = [0,1]
assert_equal(min_malware_spread(graph, initial), 0)

# Tests for union-find
graph = [[1,1,0],[1,1,1],[0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread2(graph, initial), 1)
graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
initial = [0,1]
assert_equal(min_malware_spread2(graph, initial), 1)
graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
initial = [0,1,2]
assert_equal(min_malware_spread2(graph, initial), 2)